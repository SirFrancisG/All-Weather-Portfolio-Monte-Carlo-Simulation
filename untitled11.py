# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IKyYpFH8Kz-O13JPpNZdUwb8ut-571Jk
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime as dt
import yfinance as yf
from scipy.stats import norm, percentileofscore
import matplotlib.pyplot as plt

"""
# Portfolio Setup:"""

tickers = ["VTI", "TLT", "IEF", "GLD", "DBC"]
weights = np.array([0.30, 0.40, 0.15, 0.075, 0.075])

check = sum(weights)
print (check)

"""Data"""

end_date = dt.datetime.now()
start_date = end_date - dt.timedelta(days = 252*10)

prices = yf.download(tickers, start = start_date, end = end_date)["Close"]
print(f"\nDays of data: {len(prices)}")
print(prices.tail())

"""Statistics"""

returns = prices.pct_change().dropna()

mean_returns = returns.mean().values
print(f"\nDaily average returns:\n{mean_returns}")

cov_matrix = returns.cov().values
print(f"\nCovariance Matrix\n{cov_matrix}")

from scipy.stats import kurtosis

# Kurtosis of your returns
k = kurtosis(returns, fisher=True)  # fisher=True → normal = 0
print(f"Kurtosis: {k}")

# If k > 0 → heavier tails than normal → use Student-t
# Typically for equities: k ≈ 3-10

"""#Setup simulation"""

initial_value = 10_000
n_simulation = 10000
T = 252

# For reproducibility (remove if you want different results each run)
##np.random.seed(42)

L = np.linalg.cholesky(cov_matrix)

"""#Simulation"""

portfolio_values = np.zeros((T,n_simulation))

for sim in range (n_simulation):
  current_value = initial_value
  for day in range (T):
     # 1. Generate standard random numbers (one per asset)
        Z = np.random.standard_normal(len(tickers))

        # 2. Transform into correlated returns: r = μ + L·Z
        daily_returns = mean_returns + L @ Z

        # 3. Compute portfolio return (weighted average)
        portfolio_return = np.dot(weights, daily_returns)

        # 4. Update value: V_new = V_old × (1 + r)
        current_value = current_value * (1 + portfolio_return)

        # 5. Save
        portfolio_values[day, sim] = current_value

final_values = portfolio_values[-1,:]

# Basic statistics
mean_final = np.mean(final_values)
std_final = np.std(final_values)
median_final = np.median(final_values)

# Percentiles
p5 = np.percentile(final_values, 5)    # Pessimistic case
p50 = np.percentile(final_values, 50)  # Median
p95 = np.percentile(final_values, 95)


# Probability of profit
prob_profit = np.mean(final_values > initial_value) * 100

# Print results
print("\n" + "="*50)
print("SIMULATION RESULTS")
print("="*50)
print(f"Initial value:        ${initial_value:,.0f}")
print(f"Mean final value:     ${mean_final:,.0f}")
print(f"Standard deviation:   ${std_final:,.0f}")
print(f"\nPercentiles:")
print(f"  5th (pessimistic):  ${p5:,.0f}")
print(f"  50th (median):      ${p50:,.0f}")
print(f"  95th (optimistic):  ${p95:,.0f}")
print(f"\nProbability of profit: {prob_profit:.1f}%")

"""#Charts"""

# --- PLOT 1: Simulated paths ---
plt.figure(figsize=(10, 5))
plt.plot(portfolio_values[:, :100])  # First 100 sims
plt.axhline(y=initial_value, color="red", linestyle="--", label="Initial value")
plt.xlabel("Days")
plt.ylabel("Portfolio Value ($)")
plt.title("Monte Carlo: Simulated Portfolio Paths")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig("grafico_percorsi.png", dpi=150)
plt.show()

# --- PLOT 2: Final distribution ---
plt.figure(figsize=(10, 5))
plt.hist(final_values, bins=50, density=True, alpha=0.7, color="steelblue", edgecolor="white")

# Normal fit
x = np.linspace(final_values.min(), final_values.max(), 100)
plt.plot(x, norm.pdf(x, mean_final, std_final), "r-", linewidth=2, label="Normal fit")

plt.axvline(initial_value, color="green", linestyle="--", linewidth=2, label=f"Initial: ${initial_value:,}")
plt.axvline(mean_final, color="orange", linestyle="-", linewidth=2, label=f"Mean: ${mean_final:,.0f}")

plt.xlabel("Final Value ($)")
plt.ylabel("Density")
plt.title("Distribution of Final Portfolio Values")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig("grafico_distribuzione.png", dpi=150)
plt.show()

"""Probability"""

# Example: Probability the portfolio exceeds $12,000?
target = 12_000
prob_above_target = np.mean(final_values > target) * 100
print(f"\nProbability of exceeding ${target:,}: {prob_above_target:.1f}%")

# Example: Probability of losing more than 10%?
loss_threshold = initial_value * 0.90  # $9,000
prob_loss = np.mean(final_values < loss_threshold) * 100
print(f"Probability of losing >10%: {prob_loss:.1f}%")

"""#Monte Carlo with returns"""

portfolio_returns = np.zeros(n_simulation)  # One return per simulation

for sim in range(n_simulation):

    cumulative_return = 1.0  # Starts at 1 (= 100%)

    for day in range(T):
        Z = np.random.standard_normal(len(tickers))
        daily_returns = mean_returns + L @ Z
        portfolio_return = np.dot(weights, daily_returns)

        cumulative_return *= (1 + portfolio_return)  # Compounding

    # Total return in percentage
    portfolio_returns[sim] = (cumulative_return - 1) * 100

# Analysis
print(f"Expected mean return: {np.mean(portfolio_returns):.1f}%")
print(f"Standard deviation:   {np.std(portfolio_returns):.1f}%")
print(f"5th percentile:       {np.percentile(portfolio_returns, 5):.1f}%")
print(f"95th percentile:      {np.percentile(portfolio_returns, 95):.1f}%")

# Plot
plt.hist(portfolio_returns, bins=50, density=True, alpha=0.7)
plt.axvline(0, color="red", linestyle="--", label="Break-even")
plt.xlabel("Annual Return (%)")
plt.ylabel("Density")
plt.title("Portfolio Return Distribution")
plt.legend()
plt.show()

"""#T-student

Estimate degrees of freedom
"""

from scipy.stats import kurtosis
# Compute kurtosis of portfolio returns
portfolio_hist_returns = returns @ weights
k = kurtosis(portfolio_hist_returns, fisher=True)

# Approx relationship: df ≈ 6/k + 4 (for k > 0)
if k > 0:
    df_stimato = 6 / k + 4
    print(f"Kurtosis: {k:.2f}")
    print(f"Estimated degrees of freedom: {df_stimato:.1f}")
else:
    df_stimato = 30  # Approximately normal

from scipy.stats import t

# Setup
df = df_stimato
scale = np.sqrt(df / (df - 2))

# Arrays for results
portfolio_returns = np.zeros(n_simulation)
portfolio_values = np.zeros(n_simulation)

for sim in range(n_simulation):

    cumulative_return = 1.0

    for day in range(T):
        Z = t.rvs(df, size=len(tickers)) / scale
        daily_returns = mean_returns + L @ Z
        portfolio_return = np.dot(weights, daily_returns)
        cumulative_return *= (1 + portfolio_return)

    # Save both in the same iteration
    portfolio_returns[sim] = (cumulative_return - 1) * 100
    portfolio_values[sim] = initial_value * cumulative_return


# STATISTICS
print("="*50)
print("MONTE CARLO RESULTS (Student-t)")
print("="*50)

# Returns
print(f"\nRETURNS (%)")
print(f"   Mean:            {np.mean(portfolio_returns):>8.2f}%")
print(f"   Median:          {np.median(portfolio_returns):>8.2f}%")
print(f"   Std Dev:         {np.std(portfolio_returns):>8.2f}%")
print(f"   5th percentile:  {np.percentile(portfolio_returns, 5):>8.2f}%")
print(f"   95th percentile: {np.percentile(portfolio_returns, 95):>8.2f}%")

# Values
print(f"\nFINAL VALUES ($)")
print(f"   Mean:            ${np.mean(portfolio_values):>12,.0f}")
print(f"   Median:          ${np.median(portfolio_values):>12,.0f}")
print(f"   5th percentile:  ${np.percentile(portfolio_values, 5):>12,.0f}")
print(f"   95th percentile: ${np.percentile(portfolio_values, 95):>12,.0f}")

# Probabilities
prob_profit = np.mean(portfolio_returns > 0) * 100
prob_loss_10 = np.mean(portfolio_returns < -10) * 100
prob_gain_20 = np.mean(portfolio_returns > 20) * 100

print(f"\nPROBABILITIES")
print(f"   P(gain):         {prob_profit:>8.1f}%")
print(f"   P(loss >10%):    {prob_loss_10:>8.1f}%")
print(f"   P(gain >20%):    {prob_gain_20:>8.1f}%")

"""Charts"""

from scipy.stats import norm, t as t_dist, percentileofscore


# PLOT 1: Return distribution
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# --- Plot 1: Returns histogram ---
ax1 = axes[0, 0]
ax1.hist(portfolio_returns, bins=60, density=True, alpha=0.7,
         color="steelblue", edgecolor="white", linewidth=0.5)

# Reference lines
ax1.axvline(0, color="red", linestyle="--", linewidth=2, label="Break-even")
ax1.axvline(np.mean(portfolio_returns), color="green", linestyle="-",
            linewidth=2, label=f"Mean: {np.mean(portfolio_returns):.1f}%")
ax1.axvline(np.percentile(portfolio_returns, 5), color="orange", linestyle=":",
            linewidth=2, label=f"5th: {np.percentile(portfolio_returns, 5):.1f}%")
ax1.axvline(np.percentile(portfolio_returns, 95), color="orange", linestyle=":",
            linewidth=2, label=f"95th: {np.percentile(portfolio_returns, 95):.1f}%")

ax1.set_xlabel("Return (%)", fontsize=11)
ax1.set_ylabel("Density", fontsize=11)
ax1.set_title("Return Distribution (Student-t)", fontsize=12, fontweight="bold")
ax1.legend(loc="upper right", fontsize=9)
ax1.grid(True, alpha=0.3)

# --- Plot 2: Final value distribution ---
ax2 = axes[0, 1]
ax2.hist(portfolio_values, bins=60, density=True, alpha=0.7,
         color="seagreen", edgecolor="white", linewidth=0.5)

ax2.axvline(initial_value, color="red", linestyle="--", linewidth=2,
            label=f"Initial: ${initial_value:,}")
ax2.axvline(np.mean(portfolio_values), color="blue", linestyle="-",
            linewidth=2, label=f"Mean: ${np.mean(portfolio_values):,.0f}")

ax2.set_xlabel("Final Value ($)", fontsize=11)
ax2.set_ylabel("Density", fontsize=11)
ax2.set_title("Final Value Distribution", fontsize=12, fontweight="bold")
ax2.legend(loc="upper right", fontsize=9)
ax2.grid(True, alpha=0.3)

# --- Plot 3: CDF (Cumulative probability) ---
ax3 = axes[1, 0]
sorted_returns = np.sort(portfolio_returns)
cdf = np.arange(1, len(sorted_returns) + 1) / len(sorted_returns)

ax3.plot(sorted_returns, cdf, color="steelblue", linewidth=2)
ax3.axvline(0, color="red", linestyle="--", alpha=0.7)
ax3.axhline(0.5, color="gray", linestyle=":", alpha=0.7)

# Highlight percentiles
for p, color in [(5, "orange"), (50, "green"), (95, "orange")]:
    val = np.percentile(portfolio_returns, p)
    ax3.scatter([val], [p/100], color=color, s=100, zorder=5)
    ax3.annotate(f"{p}th: {val:.1f}%", xy=(val, p/100),
                xytext=(val+5, p/100+0.05), fontsize=9)

ax3.set_xlabel("Return (%)", fontsize=11)
ax3.set_ylabel("Cumulative Probability", fontsize=11)
ax3.set_title("CDF - Cumulative Distribution Function", fontsize=12, fontweight="bold")
ax3.grid(True, alpha=0.3)

# --- Plot 4: Threshold probabilities ---
ax4 = axes[1, 1]
thresholds = np.arange(-30, 51, 5)
probs_above = [np.mean(portfolio_returns > t) * 100 for t in thresholds]

bars = ax4.bar(thresholds, probs_above, width=4, color="steelblue",
               edgecolor="white", alpha=0.8)

# Color differently above/below zero
for bar, t in zip(bars, thresholds):
    if t < 0:
        bar.set_color("salmon")
    elif t == 0:
        bar.set_color("gold")

ax4.axvline(0, color="black", linestyle="-", linewidth=1)
ax4.set_xlabel("Return Threshold (%)", fontsize=11)
ax4.set_ylabel("P(return > threshold) %", fontsize=11)
ax4.set_title("Probability of Exceeding Thresholds", fontsize=12, fontweight="bold")
ax4.grid(True, alpha=0.3, axis="y")

plt.tight_layout()
plt.savefig("monte_carlo_tstudent_analysis.png", dpi=150, bbox_inches="tight")
plt.show()

# PLOT 2: Tail comparison Normal vs Student-t (optional)
fig, ax = plt.subplots(figsize=(10, 5))

# Range for plot
x = np.linspace(-4, 4, 200)

# Normal PDF
pdf_normal = norm.pdf(x, 0, 1)

# Student-t PDF
pdf_t = t_dist.pdf(x, df) * np.sqrt(df / (df - 2))  # scaled

ax.plot(x, pdf_normal, "b-", linewidth=2, label="Normal")
ax.plot(x, pdf_t, "r-", linewidth=2, label=f"Student-t (df={df:.1f})")

# Highlight tails
ax.fill_between(x, pdf_normal, where=(x < -2.5), alpha=0.3, color="blue")
ax.fill_between(x, pdf_t, where=(x < -2.5), alpha=0.3, color="red")

ax.set_xlabel("Standard deviations", fontsize=11)
ax.set_ylabel("Density", fontsize=11)
ax.set_title("Tail Comparison: Normal vs Student-t", fontsize=12, fontweight="bold")
ax.legend(fontsize=10)
ax.grid(True, alpha=0.3)

# Annotation
ax.annotate("Heavier tails\n→ more extreme events",
            xy=(-3, 0.02), fontsize=10, ha="center",
            bbox=dict(boxstyle="round", facecolor="wheat", alpha=0.5))

plt.tight_layout()
plt.savefig("confronto_normale_tstudent.png", dpi=150, bbox_inches="tight")
plt.show()